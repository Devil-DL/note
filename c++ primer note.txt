1.标准c++规定了基本类型的最小长度
2.无符号数超出范围后取模计算，有符号数超出范围未定义
3.列表初始化基本类型时，会因为没发生类型转换而产生编译错误
4.函数体之外的变量默认初始化为0 ps:可能和常量区初始化有关
5.const常量默认只在本文件中有用，如果要跨文件，需要在所有的地方假如extern
6.std::string输入时忽略空白符，一直读取到空白符,getline的返回值是流对象
7.endl会触发缓冲区刷新
8.无符号数与带符号数运算时，带符号数会转为无符号数，可能会产生不一样的结果 ps:有符号数会转化为无符号数，范围足够的话，正数不变，但负数会转化为一个较大的值
9.std::string的size()是一个无符号的类型
10.使用{}进行初始化时，优先考虑列表初始化，再考虑初始化的函数
11.range-for不应该改变遍历序列大小
12.数组名会转化成数组首元素的指针
13.range-for访问多维数组时，为避免进行（数组名->指针的转化），应该使用引用
14.const 引用可以绑定非const，字面量以及表达式
15.函数参数是顶层const时，调用时会忽略顶层const，如果再定义非const函数会产生二义性
16.含有一个参数的构造函数会对应一个隐式转换规则，在使用explicit声明后会取消该隐式转换
17.cout中使用flust可以刷新流
18.fstream对象被销毁时，会调用close
19.容器中的元素都是备份
20.insert在迭代器之前插入元素
21.容器的at运算符会检查越界的情况
22.流迭代器存在惰性求值
23.反向迭代器调用base时，指向的元素不同，但是区间相同
24.用new初始化有默认构造函数的类时，会调用默认构造函数
25.生成的拷贝构造函数会调用所有类成员的拷贝构造函数，对于内置类型则是直接复制
26.使用'='，参数传递，函数返回，抛出异常，异常捕获中进行的初始化都是拷贝初始化 ps:该概念不同于拷贝构造函数
27.使用'()'、'{}'、new表达式、static_cast表达式的是直接初始化 
28.对于拷贝初始化，当目标是类类型的时候，参照以下规则：如果来源和目标是同一个类型，则选择no-explicit的构造函数来初始化；如果来源和目标类型不同，但是来源存在类型转化的话，先转化为临时变量，再初始化（编译器可能直接在目标构造该对象，而不进行复制，但是程序需保证copy和move有效）ps:这个规则是一个原规则的简化，去除了部分限定词和条件）
29.直接初始化是一个选择最合适构造函数进行匹配的过程
30.由于explicit修饰的构造函数不能进行隐式转换，而且不参与拷贝初始化的函数匹配过程，因此不能进行拷贝初始化
31.生成的拷贝赋值运算符重载会依次对对象的非static成员使用拷贝赋值
32.const引用可以绑定到右值上
33.移后源对象可以赋值和销毁
34.重载运算符本质上是函数调用过程，而函数调用不保证参数求值顺序，所以对于某些包含参数顺序的运算符，进行重载之后不保证原运算符的顺序关系
35.类的类型转换运算符是一个隐式转换，可以用explicit来表明显式转换，而在逻辑运算判断的部分，该转换会被直接调用，其余时候都必须显式调用
36.运算符重载至少要有这个类的一个对象
37.派生类在构造时，如果没有显式写出基类的构造函数，那么将会对基类成员进行默认初始化
38.c++11 使用final来限制继承
39.从派生类到基类的类型转换只对指针（含智能指针）和引用有效
40.公有继承时权限不变；保护继承时，基类公有成员变成保护成员；私有继承时，所有成员都是私有的
41.派生类的成员和友元函数都不能访问基类的私有成员
42.派生类可以用using来改变自己可访问的基类成员的访问权限
43.对于继承链上的函数调用，先找到调用对象的静态类型，然后依次在静态类型以及其直接基类和间接基类中查找该名字。如果在某个作用域内找到，则进行函数匹配来判断是否是正确调用。此时再根据该函数是否为虚函数以及是否使用指针或引用调用来判断调用类型。如果满足动态绑定，则调用动态类型的虚函数，否则采用静态绑定。
44.对于一个需要继承的基类，应当将析构函数定义为虚函数，以满足动态分配delete时能正确运行。
----------------------------------------------------------------------------------------------------
一些或许有用的C++知识
1.对于函数或者函数模板的名字查找，可能找到多个声明，然后对于候选集进行重载决议，最后再考虑成员的访问权限 (https://zh.cppreference.com/w/cpp/language/lookup)
2.模板定义中的非依赖名，在定义时就进行名字查找和绑定，不受实例化点影响；依赖名的查找推迟到知道模板实参之后(https://zh.cppreference.com/w/cpp/language/unqualified_lookup)
3. 函数的返回值是左值引用时，函数调用表达式成为左值表达式 (https://zh.cppreference.com/w/cpp/language/reference)
4. 函数调用其返回类型是非引用时，该表达式为纯右值(https://zh.cppreference.com/w/cpp/language/reference)
5. 继承过程中的静态成员只有一份